<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[さめたすたすのお家]]></title>
    <link href="http://www.sharkpp.net/blog/categories/%E3%83%9D%E3%82%B1%E3%82%B3%E3%83%B3%E8%AC%9B%E5%BA%A7.xml" rel="self"/>
    <link href="http://www.sharkpp.net/"/>
    <updated>2020-12-31T12:53:45+00:00</updated>
    <id>http://www.sharkpp.net/</id>
            <author>
            <name><![CDATA[sharkpp]]></name>                    </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[C言語講座 第三回 巨大なプログラムの実行]]></title>
            <link href="http://www.sharkpp.net/blog/2008/07/20/pokecom-lecture-03-large-size-program-run.html"/>
            <updated>2008-07-20T23:37:00+00:00</updated>
            <id>http://www.sharkpp.net/blog/2008/07/20/pokecom-lecture-03-large-size-program-run.html</id>
            <content type="html"><![CDATA[<h2 id="%E5%A7%8B%E3%82%81%E3%81%AB">始めに</h2>

<!-- 20050206 -->

<p>第三回のＣ言語 講座は、巨大なプログラムの実行を扱うことにします。</p>

<p>前回の講座でファイルサイズの縮小を扱いましたが、それでも限界があります。</p>

<p>ゲームを作ろうとすると、すぐにサイズが1000バイトを超えてしまい、さらに、5000バイトになることもまれではないと思います。</p>

<p>開発するには、ファイルを読込んでコンパイルをしなければいけませんが、ゲームなどのプログラムを実行するだけなら、なんと大きいファイルを読込まなくてもコンパイル＆実行が出来てしまうのです。</p>

<h2 id="%E5%85%B6%E3%81%AE%E5%A3%B1">其の壱</h2>

<p>前提条件</p>

<ul>
<li><p>プログラムを読込む事は出来るが、コンパイルできない</p>

<p>(比較的、プログラムの後ろのほうで <code>Memory full</code> エラーがでる場合) </div></p></li>
</ul>

<h2 id="%E5%85%B6%E3%81%AE%E5%BC%90">其の弐</h2>

<p>&lt;</p>

<p>div></p>

<p>
まず、ポケコンで実行したいプログラム(例えばゲーム)を転送してください。<br /> サイズにもよりますが、3000バイトのもので、4・5本ぐらい(たぶん)は転送できると思います。<br /> BASICプログラムでC言語プログラムが実行できない場合にもこのテクニックは使えます。<br /> また、転送できて、保存は出来たけど、別のプログラムをロードしてもコンパイルできないときにも使えます。
</p>

<p>
次に、以下のソースを打ち込んでください。<br /> <em>"実行したいプログラム名"</em> の部分には <code>"poyopoyo.c"</code> などとコンパイルできないプログラム名を指定してください。
</p>

<pre>
#include <i>"実行したいプログラム名"</i>
</pre>

<p>
これをコンパイルすると、プログラムが動くと思います。<br /> これは、ポケコンがコンパイルするときにメモリ上のアドレスから読込んでいるからだと<span>(てか全部メモリだし)</span>。<br /> これでも、コンパイルができない場合には、諦めてください(ぉ
</p>

<h2>
最後に
</h2>

<p>
今回は、講座と言うよりも、プチテクニック的なところが在ったけど、そろそろ、ネタ切れか？<br /> これも、かなり前に思いついたものなんだけど、思いつきの割には役に立ちそうな気がする。<br /> 開発中にも急場をしのげる気がする(このテクニックを使えば大作RPGも夢じゃない？)
</p>

<h2>
履歴
</h2>

<dl>
<dt>2004/08/15</dt>
<dd>公開</dd>

<dt>2005/02/06</dt>
<dd>構成変更</dd>
</dl>

<div class="siblings_navigation">
<a href="/blog/2008/07/20/pokecom-lecture-01-key-input.html" title="C言語講座 第一回 キー入力" >前</a> | C言語講座 第三回 巨大なプログラムの実行 | 次
</div>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[C言語講座 第二回 ファイルサイズの縮小]]></title>
            <link href="http://www.sharkpp.net/blog/2008/07/20/pokecom-lecture-02-file-size-compact.html"/>
            <updated>2008-07-20T23:36:00+00:00</updated>
            <id>http://www.sharkpp.net/blog/2008/07/20/pokecom-lecture-02-file-size-compact.html</id>
            <content type="html"><![CDATA[<h2 id="%E5%A7%8B%E3%82%81%E3%81%AB">始めに</h2>

<!-- 20050206 -->

<p>第二回のＣ言語 講座は、ファイルサイズの縮小を扱うことにします。</p>

<p>ポケコンでＣ言語のプログラムを作成するメリットは、「BASICプログラムよりも実行速度が速い」ことが挙げられます。 当然ですが、マシン語には実行速度はかないません(プログラム言語の中では最速です)。<span>←当たり前だ</span></p>

<p>ただ、Ｃ言語でプログラムを作ったことがある人は、分かると思いますが、BASICに比べてファイルサイズが大きすぎるのです。</p>

<h2 id="%E5%85%B6%E3%81%AE%E5%A3%B1">其の壱</h2>

<p>まず、以下のソースを見てください。</p>

<pre>void main(void)
{
int c;
while(1) {
c = getch();
printf("KEY = %c[%02X] \n", c, c);
}
}
</pre>

<p>プログラム的には、キーを取得し、その値をキャラクタと16進のキャラクタコードを表示するだけのプログラムです。 <!-- まあだいたい、基本的にはこんな感じですね(異論があるかもしれませんが)。 --></p>

<p>まず、基本的に省略可能な部分から省略していきます。</p>

<ol>
<li>void を省略</li>
<li>見やすいように入れてある空白・改行を削除</li>
<li>大カッコ( { )を移動</li>
<li>while(1) を for(;;) に(動作結果が同じなので)</li>
</ol>

<pre>main(){
int c;
for(;;){
c=getch();
printf("KEY = %c[%02X] \n",c,c);
}}
</pre>

<p>でこんな感じです。</p>

<p>これで、だいたい 126byte → 77byte ぐらいです。</p>

<p>ずいぶん見にくくなりました。</p>

<p>さらに、一行にまとめると、</p>

<pre>main(){int c;for(;;){c=getch();printf("KEY = %c[%02X] \n",c,c);}}
</pre>

<p>結果、126byte から 59byte減って、67byte になりました。</p>

<p>が、エーと、ものすごく見にくいです。</p>

<p><span>(そのぐらいは、我慢してください...)
</span></p>

<h2 id="%E5%85%B6%E3%81%AE%E5%BC%90">其の弐</h2>

<p>また、文字の表示位置の変更のために <code>gotoxy()</code> などを大量に使っている時に効果的なのが、 <code>#define</code> です。</p>

<p><code>gotoxy()</code> を例に、簡単に計算方法を書いてみます。</p>

<pre>main(){
gotoxy(8,2);putchar(43);gotoxy(3,2);putchar(104);
gotoxy(6,2);putchar(107);gotoxy(4,2);putchar(97);
gotoxy(5,2);putchar(114);gotoxy(7,2);putchar(43);
gotoxy(9,2);putchar(33);gotoxy(2,2);putchar(83);
}
</pre>

<p>上記のプログラムを下のように変更すると</p>

<pre>#define gxy gotoxy
main(){
gxy(8,2);putchar(43);gxy(3,2);putchar(104);
gxy(6,2);putchar(107);gxy(4,2);putchar(97);
gxy(5,2);putchar(114);gxy(7,2);putchar(43);
gxy(9,2);putchar(33);gxy(2,2);putchar(83);
}
</pre>

<p>で、実際の計算は、<code>8 × (6 - 3) - 18 - 4 = 2</code> です。</p>

<p>だだし、</p>

<p><code>&amp;nbsp;8 =</code> 元の名称の数 → <code>"gotoxy"</code> の数</p>

<p><code>&amp;nbsp;6 =</code> 元の名称の文字数</p>

<p><code>&amp;nbsp;3 =</code> 新名称の文字数 → <code>"gxy"</code></p>

<p><code>18 =</code> 追加した行の文字数 → <code>"#define gxy gotoxy"</code></p>

<p><code>&amp;nbsp;4 =</code> 行番号＋改行</p>

<p><strong>計算結果の値が、＋の値になったら、減らすことが出来るということです。</strong></p>

<p>ただし、新名称は、どんな名前でもいいのですが、<span>くれぐれも変数名と重ならないように</span>してください。</p>

<p>ファイルサイズの縮小は、アイデア次第？でかなり削れます<span>(その分、見にくいですが)</span>。</p>

<p>皆さんも頑張ってください。</p>

<h2 id="%E6%9C%80%E5%BE%8C%E3%81%AB">最後に</h2>

<!-- 20050206 -->

<p>最後に、この講座は乗せるかかどうか迷ったんですが <span>(プログラミングスタイルにかかわるので)</span>、 まあ、ヘ～、てな具合に見てくれればいいかなという事を付け足しておきます。</p>

<p>単純に書くことが無いだけだったりして。</p>

<h2 id="%E5%B1%A5%E6%AD%B4">履歴</h2>

<dl>
<dt>2004/03/02</dt>
<dd>公開</dd>

<dt>2005/02/06</dt>
<dd>構成変更</dd>
</dl>

<div class="siblings_navigation"><a href="/blog/2008/07/20/pokecom-lecture-01-key-input.html" title="C言語講座 第一回 キー入力" >前</a> | C言語講座 第二回 ファイルサイズの縮小 | <a href="/blog/2008/07/20/pokecom-lecture-03-large-size-program-run.html" title="C言語講座 第三回 巨大なプログラムの実行" >次</a>
</div>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[C言語講座 第一回 キー入力]]></title>
            <link href="http://www.sharkpp.net/blog/2008/07/20/pokecom-lecture-01-key-input.html"/>
            <updated>2008-07-20T23:36:00+00:00</updated>
            <id>http://www.sharkpp.net/blog/2008/07/20/pokecom-lecture-01-key-input.html</id>
            <content type="html"><![CDATA[<h2 id="%E5%A7%8B%E3%82%81%E3%81%AB">始めに</h2>

<!-- 20050206 -->

<p>ポケコンの、BASIC には INKEY$ があるのに、Ｃ言語には、<code>getch()</code> と <code>kbhit()</code> しかないんじゃ? というわけで、第一回のＣ言語 講座は、キー入力を扱うことにします。</p>

<h2 id="%E5%85%B6%E3%81%AE%E5%A3%B1">其の壱</h2>

<!-- 20050206 -->

<p>まず、<code>getch()</code> と <code>kbhit()</code> を組み合わせて、</p>

<pre>int inkey()
{
if(kbhit())
return getch();
return 0;
}
main()
{
int c;
while(1) {
c = inkey();
printf("KEY = %c[%02X] \n", c, c);
}
}
</pre>

<p>として、キーを入力しようとしても、なぜキーを入力すると表示がとまってしまうのかというと、 おそらく <code>getch()</code> が内部でキー入力を待っているので停止しているからなのだと考えられます。</p>

<h2 id="%E5%85%B6%E3%81%AE%E5%BC%90">其の弐</h2>

<!-- 20050206 -->

<p>そこで、Ｃ言語でキーを入力するために <code>call()</code> 命令を<!-- 20050206:実現して -->使ってみようという事になります。</p>

<p>以下は、<a href="http://freett.com/hazy/">「未完成な張りぼて」</a>からの引用です ^_^;</p>

<p><code>main()</code> は上のプログラムを使ってください。</p>

<pre>char inkeyt1(void){    <span>/*キー入力関数軽量型（不都合あり）*/</span>
static char *p="へSセヘVセ2ェ□ノ";    <span>/*□はスペース*/</span>
call((unsigned)p ,0);
return (peek(0x20aa));
}
</pre>

<p>「未完成な張りぼて」では詳しく触れられていないようなので、逆アセして解析してみます。</p>

<p><code>call()</code> で呼び出している、<code>p</code> が一番肝心なプログラムです。</p>

<pre>ORG   100H
CALL  0BE53H      <span>;  0xBE53 をコール</span>
CALL  0BE56H      <span>;  0xBE56 をコール</span>
LD    (20AAH),A   <span>;  0x20AA 番地に A レジスタ値を書き出し</span>
RET               <span>;  戻る</span>
END
</pre>

<p>てな具合です。</p>

<p><code>0xBE53</code> は キー入力 の ROM 内関数で、</p>

<p><code>0xBE56</code> は <code>0xBE53</code> からの戻り値を "アスキーコードに変換" する ROM 内関数<del>のよう</del>です。</p>

<p><del>(‥のようです、というのは、どこにも記載がないからです。結果からするとおそらく、ということです。)
</del></p>

<p><span>(2005/02/06)教員用の指導書に記載がありました。
</span></p>

<p>で、どんな不具合が発生するかというと、<code>0x20AA</code> 番地に書き出すことが曲者であって、 もし <code>0x20AA</code> 番地に他のプログラムがあった場合にはそれと書きつぶしてしまうことが問題なのです。</p>

<p>そこで、<code>LD (20AAH),A</code> を <code>LD (0FFH),A</code> にしてみたら、</p>

<pre>int inkey()
{
static char *p="へSセヘVセ2\xff\0ノ";
call((unsigned)p ,0);
return peek(0x20aa);
}
</pre>

<p>こうなりました。</p>

<p>しかし、これでもまだ、不安が残ります。 もし、<code>0xFF</code> 番地にステータスを記録するプログラムだった場合は？</p>

<h2 id="%E5%85%B6%E3%81%AE%E5%8F%82">其の参</h2>

<!-- 20050206 -->

<p>そこで、<code>call()</code> をおさらいしてみます。</p>

<pre>unsigned call(unsigned adr, void * arg_HL);
adr    : 機械語の先頭アドレス
arg_HL : HL レジスタに渡される値
戻り値 : HL レジスタの値
</pre>

<p>だそうです。</p>

<p>そこで、この戻り値を利用し値を返すことにします。</p>

<p>まず、アセンブラソースです。</p>

<pre>ORG     100H
CALL    0BE53H      <span>;  0xBE53 をコール</span>
CALL    0BE56H      <span>;  0xBE56 をコール</span>
LD      L,A         <span>;  L レジスタに A レジスタ値を書き出し</span>
RET                 <span>;  戻る</span>
END
</pre>

<p>根本的には、変化していないのですが、<code>LD (0FFH),A</code> の部分を変更しました。</p>

<p>なんか使い方が間違っているような気もしますが、Ｃ言語のソースは、こうなりました。</p>

<pre>int inkey()
{
static char *p="ヘＳセヘＶセｏノ"; <span>/* 全て全角にしてあります */</span>
return call((unsigned)p,0);
}
</pre>

<p>結構すっきりしたと思います。</p>

<p><strong>ちなみに、このプログラムは、同時にはキーを取得できません。</strong></p>

<p><code>call()</code> で機械語を呼び出し、結果を HL レジスタを戻り値としてキーコードを返しています。</p>

<p>H レジスタは、呼び出し時に 0 になっているので結果的に L レジスタの値が戻ってくるわけです。</p>

<h2 id="%E6%9C%80%E5%BE%8C%E3%81%AB">最後に</h2>

<!-- 20050206 -->

<p>長々と<!-- 20050206:講座をやってきた -->書いた割には、重要なのは、上のプログラムだけ(しかも、他人のふんどしで相撲を取っているし)。</p>

<p>まあ、第一回の講座は、これでお開きです。</p>

<p>最後に、プログラムとキーコード表をのせたいと思います。</p>

<p>長々とお付き合いありがとうございました。</p>

<p>プログラム <a href="/files/inkey.h">inkey.h</a></p>

<p>　名前を inkey.h に変え、</p>

<p>　<code>#include "inkey.h"</code></p>

<p>　として読込むか、直接記述してお使いください。</p>

<table class="table table-striped" style="font-size: small;" summary="inkey.h で取得できるキーのコード表"><caption>キーコード表</caption> 
<tr><th>下位＼上位</th><th style="width: 1em;"></th><th style="width: 1em;">1</th><th style="width: 1em;">2</th><th style="width: 1em;">3</th><th style="width: 1em;">4</th><th style="width: 1em;">5</th><th style="width: 1em;">6</th><th style="width: 1em;">7</th><th style="width: 1em;">～</th><th style="width: 1em;">D</th><th style="width: 1em;">～</th><th style="width: 1em;">F</th></tr>
<tr><th ></th><td>入力なし</td><td><span>2ndF</span></td><td>スペース</td><td></td><td>@</td><td>P</td><td></td><td>p</td><td rowspan="16"></td><td rowspan="15"></td><td rowspan="16"></td><td><span>ASMBL</span></td></tr>
<tr><th>1</th><td><span>BASIC</span></td><td><span>カナ</span></td><td>!</td><td>1</td><td>A</td><td>Q</td><td>a</td><td>q</td><td><span>BASE-n</span></td></tr>
<tr><th>2</th><td><span>TEXT</span></td><td><span>INS</span></td><td>"</td><td>2</td><td>B</td><td>R</td><td>b</td><td>r</td><td><span>コントラスト</span></td></tr>
<tr><th>3</th><td><span>C</span></td><td><span>DRG</span></td><td>#</td><td>3</td><td>C</td><td>S</td><td>c</td><td>s</td><td></td></tr>
<tr><th>4</th><td><span>STAT</span></td><td><span>CAPS</span></td><td>$</td><td>4</td><td>D</td><td>T</td><td>d</td><td>t</td><td></td></tr>
<tr><th>5</th><td></td><td><span>ANS</span></td><td>%</td><td>5</td><td>E</td><td>U</td><td>e</td><td>u</td><td></td></tr>
<tr><th>6</th><td><span>OFF</span></td><td>(-)</td><td>&</td><td>6</td><td>F</td><td>V</td><td>f</td><td>v</td><td></td></tr>
<tr><th>7</th><td><span>P⇔NP</span></td><td><span>CONST</span></td><td>'</td><td>7</td><td>G</td><td>W</td><td>g</td><td>w</td><td></td></tr>
<tr><th>8</th><td><span>BS</span></td><td><span>(CONST)</span></td><td>(</td><td>8</td><td>H</td><td>X</td><td>h</td><td>x</td><td></td></tr>
<tr><th>9</th><td><span>DEL</span></td><td><span>R・CM</span></td><td>)</td><td>9</td><td>I</td><td>Y</td><td>i</td><td>y</td><td></td></tr>
<tr><th>A</th><td><span>TAB</span></td><td><span>M+</span></td><td>*</td><td>:</td><td>J</td><td>Z</td><td>j</td><td>z</td><td></td></tr>
<tr><th>B</th><td><span>CA</span></td><td><span>M-</span></td><td>+</td><td>;</td><td>K</td><td>[</td><td>k</td><td>{</td><td>”</td></tr>
<tr><th>C</th><td><span>CLS</span></td><td>→</td><td>,</td><td><</td><td>L</td><td>\</td><td>l</td><td>|</td><td></td></tr>
<tr><th>D</th><td><span class="fa fa-reply fa-flip-vertical" title="RETURN"></span></td><td>←</td><td>-</td><td>=</td><td>M</td><td>]</td><td>m</td><td>}</td><td></td></tr>
<tr><th>E</th><td><span>DIGIT</span></td><td>↑</td><td>.</td><td>></td><td>N</td><td>^</td><td>n</td><td>~</td><td>他のキー</td></tr>
<tr><th>F</th><td><span>F⇔E</span></td><td>↓</td><td>/</td><td>?</td><td>O</td><td>_</td><td>o</td><td></td><td>゜</td><td></td></tr>
</table>

<p>※<span>色</span>文字 特殊なキーの名前</p>

<p>※<span>色</span>文字 [2ndF] または [SHIFT] を押したときの名前</p>

<h2 id="%E5%B1%A5%E6%AD%B4">履歴</h2>

<dl>
<dt>2004/02/24</dt>
<dd>公開</dd>

<dt>2005/02/06</dt>
<dd>注釈追加<br />構成変更</dd>
</dl>

<div class="siblings_navigation">前 | C言語講座 第一回 キー入力 | <a href="/blog/2008/07/20/pokecom-lecture-02-file-size-compact.html" title="C言語講座 第二回 ファイルサイズの縮小" >次</a>
</div>
]]></content>
        </entry>
    </feed>